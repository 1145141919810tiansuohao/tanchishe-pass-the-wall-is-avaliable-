<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è´ªåƒè›‡æ¸¸æˆ - AIä¿®å¤ç‰ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .game-container {
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 100vw;
            max-height: 100vh;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.8em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .game-info {
            margin-bottom: 10px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-wrap: wrap;
            font-size: 0.9em;
        }

        .score {
            font-weight: bold;
            color: #4CAF50;
        }

        .speed {
            font-weight: bold;
            color: #FF9800;
        }

        .boundary-status {
            font-weight: bold;
            color: #2196F3;
        }

        .ai-status {
            font-weight: bold;
            color: #9C27B0;
        }

        .game-over {
            background: #ff6b6b;
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            font-weight: bold;
            margin: 10px auto;
        }

        .game-over button {
            background: #fff;
            color: #ff6b6b;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            margin-top: 8px;
            transition: all 0.3s ease;
        }

        .game-over button:hover {
            background: #f0f0f0;
            transform: scale(1.05);
        }

        #gameCanvas {
            border: 3px solid #333;
            border-radius: 10px;
            background: #000;
            display: block;
            margin: 0 auto 10px auto;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            max-width: 90vw;
            max-height: 50vh;
        }

        .mobile-controls {
            display: block;
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .dpad-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 10px;
        }

        .dpad-row {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 3px 0;
        }

        .dpad-btn {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(145deg, #4CAF50, #45a049);
            color: white;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            transition: all 0.1s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            margin: 0 3px;
            touch-action: manipulation;
        }

        .dpad-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .dpad-center {
            background: linear-gradient(145deg, #FF9800, #F57C00);
            font-size: 16px;
        }

        .action-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .action-btn {
            width: 60px;
            height: 40px;
            border: none;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            transition: all 0.1s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            touch-action: manipulation;
        }

        .action-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .boundary-btn {
            background: linear-gradient(145deg, #2196F3, #1976D2);
        }

        .ai-btn {
            background: linear-gradient(145deg, #9C27B0, #7B1FA2);
        }

        .restart-btn {
            background: linear-gradient(145deg, #FF5252, #D32F2F);
        }

        .pause-menu, .instructions-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .pause-content, .instructions-content {
            background: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 90vw;
            max-height: 80vh;
            overflow-y: auto;
        }

        .pause-content h2, .instructions-content h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .pause-content .button-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .pause-content button, .instructions-content button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .pause-content button:hover, .instructions-content button:hover {
            background: #45a049;
            transform: scale(1.05);
        }

        .instructions-text {
            text-align: left;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        .instructions-text h3 {
            color: #4CAF50;
            margin: 10px 0 5px 0;
            font-size: 1.1em;
        }

        .instructions-text p {
            color: #666;
            margin: 3px 0;
            line-height: 1.4;
        }

        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 480px) {
            .game-container {
                padding: 10px;
            }
            
            h1 {
                font-size: 1.5em;
                margin-bottom: 8px;
            }
            
            .game-info {
                font-size: 0.8em;
            }
            
            .dpad-btn {
                width: 45px;
                height: 45px;
                font-size: 18px;
            }
            
            .action-btn {
                width: 55px;
                height: 35px;
                font-size: 11px;
            }
        }

        @media (max-width: 360px) {
            .dpad-btn {
                width: 40px;
                height: 40px;
                font-size: 16px;
                margin: 0 2px;
            }
            
            .action-btn {
                width: 50px;
                height: 32px;
                font-size: 10px;
            }
            
            h1 {
                font-size: 1.3em;
            }
        }

        @media (max-width: 320px) {
            .dpad-btn {
                width: 35px;
                height: 35px;
                font-size: 14px;
            }
            
            .action-btn {
                width: 45px;
                height: 30px;
                font-size: 9px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>è´ªåƒè›‡æ¸¸æˆ</h1>
        <div class="game-info">
            <div class="score">å¾—åˆ†: <span id="score">0</span></div>
            <div class="speed">é€Ÿåº¦: <span id="speed">300</span>ms</div>
            <div class="boundary-status">è¾¹ç•Œ: <span id="boundaryStatus">å¼€å¯</span></div>
            <div class="ai-status">AI: <span id="aiStatus">å…³é—­</span></div>
        </div>
        <div class="game-over" id="gameOver" style="display: none;">
            <p>æ¸¸æˆç»“æŸï¼</p>
            <button onclick="restartGame()">é‡æ–°å¼€å§‹</button>
        </div>
        <canvas id="gameCanvas" width="400" height="400"></canvas>
        
        <!-- ç§»åŠ¨ç«¯è™šæ‹ŸæŒ‰é”® -->
        <div class="mobile-controls" id="mobileControls">
            <div class="dpad-container">
                <div class="dpad-row">
                    <button class="dpad-btn dpad-up" ontouchstart="handleMobileControl('up')" ontouchend="stopMobileControl()" ontouchcancel="stopMobileControl()">â–²</button>
                </div>
                <div class="dpad-row">
                    <button class="dpad-btn dpad-left" ontouchstart="handleMobileControl('left')" ontouchend="stopMobileControl()" ontouchcancel="stopMobileControl()">â—€</button>
                    <button class="dpad-btn dpad-center" ontouchstart="handleMobileControl('pause')" ontouchend="stopMobileControl()" ontouchcancel="stopMobileControl()">â¸</button>
                    <button class="dpad-btn dpad-right" ontouchstart="handleMobileControl('right')" ontouchend="stopMobileControl()" ontouchcancel="stopMobileControl()">â–¶</button>
                </div>
                <div class="dpad-row">
                    <button class="dpad-btn dpad-down" ontouchstart="handleMobileControl('down')" ontouchend="stopMobileControl()" ontouchcancel="stopMobileControl()">â–¼</button>
                </div>
            </div>
            <div class="action-buttons">
                <button class="action-btn boundary-btn" ontouchstart="handleMobileControl('boundary')" ontouchend="stopMobileControl()" ontouchcancel="stopMobileControl()">è¾¹ç•Œ</button>
                <button class="action-btn ai-btn" ontouchstart="handleMobileControl('ai')" ontouchend="stopMobileControl()" ontouchcancel="stopMobileControl()">AI</button>
                <button class="action-btn restart-btn" ontouchstart="handleMobileControl('restart')" ontouchend="stopMobileControl()" ontouchcancel="stopMobileControl()">é‡å¯</button>
            </div>
        </div>
        <div class="pause-menu" id="pauseMenu" style="display: none;">
            <div class="pause-content">
                <h2>æ¸¸æˆæš‚åœ</h2>
                <div class="button-container">
                    <button onclick="togglePause()">ç»§ç»­æ¸¸æˆ</button>
                    <button onclick="restartFromPause()">é‡æ–°å¼€å§‹</button>
                    <button onclick="showInstructions()">ç©æ³•ä»‹ç»</button>
                </div>
            </div>
        </div>
        <div class="instructions-menu" id="instructionsMenu" style="display: none;">
            <div class="instructions-content">
                <h2>ç©æ³•ä»‹ç»</h2>
                <div class="instructions-text">
                    <h3>ğŸ® åŸºæœ¬æ“ä½œ</h3>
                    <p>â€¢ ä½¿ç”¨è™šæ‹Ÿæ–¹å‘é”®æ§åˆ¶è›‡çš„ç§»åŠ¨</p>
                    <p>â€¢ æŒ‰æš‚åœé”®æš‚åœ/ç»§ç»­æ¸¸æˆ</p>
                    <p>â€¢ æŒ‰è¾¹ç•Œé”®åˆ‡æ¢è¾¹ç•Œå¼€å…³</p>
                    
                    <h3>ğŸ¯ æ¸¸æˆç›®æ ‡</h3>
                    <p>â€¢ æ§åˆ¶è›‡åƒåˆ°é£Ÿç‰©ï¼ˆçº¢è‰²æ–¹å—ï¼‰</p>
                    <p>â€¢ æ¯åƒä¸€ä¸ªé£Ÿç‰©å¾—1åˆ†</p>
                    <p>â€¢ è›‡èº«ä¼šéšç€åƒé£Ÿç‰©è€Œå˜é•¿</p>
                    
                    <h3>âš¡ åŠ é€Ÿç³»ç»Ÿ</h3>
                    <p>â€¢ åˆå§‹é€Ÿåº¦ï¼š300ms</p>
                    <p>â€¢ æ¯è·å¾—3åˆ†ï¼Œé€Ÿåº¦å¢åŠ 30ms</p>
                    <p>â€¢ æœ€é«˜é€Ÿåº¦ï¼š120ms</p>
                    
                    <h3>ğŸŒ è¾¹ç•Œå¼€å…³</h3>
                    <p>â€¢ è¾¹ç•Œå¼€å¯ï¼šæ’åˆ°å¢™å£æ¸¸æˆç»“æŸ</p>
                    <p>â€¢ è¾¹ç•Œå…³é—­ï¼šå¯ä»å¯¹é¢è¾¹ç•Œç©¿è¶Šå‡ºç°</p>
                    <p>â€¢ æŒ‰è¾¹ç•Œé”®éšæ—¶åˆ‡æ¢è¾¹ç•ŒçŠ¶æ€</p>
                    
                    <h3>ğŸ¤– AIè‡ªåŠ¨æ¨¡å¼</h3>
                    <p>â€¢ æŒ‰Qé”®ï¼ˆç”µè„‘ç«¯ï¼‰æˆ–AIé”®ï¼ˆç§»åŠ¨ç«¯ï¼‰å¼€å¯/å…³é—­AIæ¨¡å¼</p>
                    <p>â€¢ AIä¼šè‡ªåŠ¨å¯»æ‰¾é£Ÿç‰©å¹¶é¿å…ç¢°æ’</p>
                    <p>â€¢ å¼€å¯AIåï¼Œæ–¹å‘é”®å°†å¤±æ•ˆ</p>
                    
                    <h3>âš ï¸ æ¸¸æˆè§„åˆ™</h3>
                    <p>â€¢ ä¸èƒ½æ’åˆ°è‡ªå·±çš„èº«ï¿½ï¿½ï¿½</p>
                    <p>â€¢ ä¸èƒ½è¿›è¡Œ180Â°è½¬å¼¯ï¼ˆå¦‚æ­£åœ¨å‘å³ä¸èƒ½ç«‹å³å‘å·¦ï¼‰</p>
                </div>
                <button onclick="hideInstructions()">è¿”å›</button>
            </div>
        </div>
    </div>

    <script>
        // æ¸¸æˆçŠ¶æ€å˜é‡
        let canvas, ctx;
        let snake = [];
        let food = {};
        let direction = 'right';
        let nextDirection = 'right';
        let gameRunning = false;
        let gamePaused = false;
        let gameLoop;
        let aiLoop;
        let score = 0;
        let currentSpeed = 300;
        let boundaryEnabled = true;
        let aiMode = false;
        let aiInterval;
        let aiIntervalTime = 100;

        // æ¸¸æˆé…ç½®
        const GRID_SIZE = 35;
        const INITIAL_SNAKE_LENGTH = 1;
        const SPEED_INCREMENT = 30;
        const MIN_SPEED = 80;
        const INITIAL_SPEED = 200;

        // ç§»åŠ¨ç«¯æ§åˆ¶çŠ¶æ€
        let mobileControlActive = false;
        let mobileControlDirection = null;

        // è·å–DOMå…ƒç´ 
        function getElements() {
            return {
                canvas: document.getElementById('gameCanvas'),
                scoreElement: document.getElementById('score'),
                speedElement: document.getElementById('speed'),
                boundaryElement: document.getElementById('boundaryStatus'),
                aiElement: document.getElementById('aiStatus'),
                gameOverElement: document.getElementById('gameOver'),
                pauseMenuElement: document.getElementById('pauseMenu'),
                instructionsMenuElement: document.getElementById('instructionsMenu')
            };
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            const elements = getElements();
            canvas = elements.canvas;
            ctx = canvas.getContext('2d');
            
            // æ ¹æ®å±å¹•å¤§å°è°ƒæ•´ç”»å¸ƒå°ºå¯¸
            adjustCanvasSize();
            
            // åˆå§‹åŒ–è›‡
            initSnake();
            
            // ç”Ÿæˆé£Ÿç‰©
            generateFood();
            
            // é‡ç½®æ¸¸æˆçŠ¶æ€
            score = 0;
            currentSpeed = INITIAL_SPEED;
            direction = 'right';
            nextDirection = 'right';
            gameRunning = true;
            gamePaused = false;
            
            // æ›´æ–°æ˜¾ç¤º
            updateDisplay();
            
            // å¼€å§‹æ¸¸æˆå¾ªç¯
            startGameLoop();
            
            // å¦‚æœAIæ¨¡å¼å¼€å¯ï¼Œå¯åŠ¨AIæ§åˆ¶
            if (aiMode) {
                startAIControl();
            }
        }

        // è°ƒæ•´ç”»å¸ƒå°ºå¯¸ä»¥é€‚åº”æ‰‹æœºå±å¹•
        function adjustCanvasSize() {
            const maxWidth = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.5);
            const maxHeight = maxWidth;
            
            // ç¡®ä¿ç”»å¸ƒå°ºå¯¸æ˜¯GRID_SIZEçš„å€æ•°
            const size = Math.floor(maxWidth / GRID_SIZE) * GRID_SIZE;
            
            canvas.width = size;
            canvas.height = size;
        }

        // åˆå§‹åŒ–è›‡
        function initSnake() {
            snake = [];
            const startX = Math.floor(GRID_SIZE / 2);
            const startY = Math.floor(GRID_SIZE / 2);
            
            for (let i = 0; i < INITIAL_SNAKE_LENGTH; i++) {
                snake.push({
                    x: startX - i,
                    y: startY
                });
            }
        }

        // ç”Ÿæˆé£Ÿç‰©
        function generateFood() {
            do {
                food = {
                    x: Math.floor(Math.random() * GRID_SIZE),
                    y: Math.floor(Math.random() * GRID_SIZE)
                };
            } while (isSnakePosition(food.x, food.y));
        }

        // æ£€æŸ¥æ˜¯å¦æ˜¯è›‡èº«ä½ç½®
        function isSnakePosition(x, y) {
            return snake.some(segment => segment.x === x && segment.y === y);
        }

        // ç»˜åˆ¶æ¸¸æˆ
        function draw() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶è›‡
            drawSnake();
            
            // ç»˜åˆ¶é£Ÿç‰©
            drawFood();
        }

        // ç»˜åˆ¶è›‡
        function drawSnake() {
            const cellSize = canvas.width / GRID_SIZE;
            
            snake.forEach((segment, index) => {
                if (index === 0) {
                    // è›‡å¤´
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(segment.x * cellSize + 1, segment.y * cellSize + 1, cellSize - 2, cellSize - 2);
                } else {
                    // è›‡èº«
                    ctx.fillStyle = '#66BB6A';
                    ctx.fillRect(segment.x * cellSize + 1, segment.y * cellSize + 1, cellSize - 2, cellSize - 2);
                }
            });
        }

        // ç»˜åˆ¶é£Ÿç‰©
        function drawFood() {
            const cellSize = canvas.width / GRID_SIZE;
            
            ctx.fillStyle = '#FF5252';
            ctx.fillRect(food.x * cellSize + 2, food.y * cellSize + 2, cellSize - 4, cellSize - 4);
        }

        // æ›´æ–°æ¸¸æˆçŠ¶æ€
        function update() {
            if (!gameRunning || gamePaused) return;
            
            // æ›´æ–°æ–¹å‘
            direction = nextDirection;
            
            // ç§»åŠ¨è›‡å¤´
            const head = { ...snake[0] };
            
            switch (direction) {
                case 'up':
                    head.y--;
                    break;
                case 'down':
                    head.y++;
                    break;
                case 'left':
                    head.x--;
                    break;
                case 'right':
                    head.x++;
                    break;
            }
            
            // è¾¹ç•Œå¤„ç†
            if (boundaryEnabled) {
                // æ£€æŸ¥è¾¹ç•Œç¢°æ’
                if (head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE) {
                    gameOver();
                    return;
                }
            } else {
                // è¾¹ç•Œç©¿è¶Š
                if (head.x < 0) head.x = GRID_SIZE - 1;
                if (head.x >= GRID_SIZE) head.x = 0;
                if (head.y < 0) head.y = GRID_SIZE - 1;
                if (head.y >= GRID_SIZE) head.y = 0;
            }
            
            // æ£€æŸ¥è‡ªèº«ç¢°æ’
            if (isSnakePosition(head.x, head.y)) {
                gameOver();
                return;
            }
            
            // æ·»åŠ æ–°å¤´éƒ¨
            snake.unshift(head);
            
            // æ£€æŸ¥æ˜¯å¦åƒåˆ°é£Ÿç‰©
            if (head.x === food.x && head.y === food.y) {
                score++;
                generateFood();
                updateSpeed();
                updateDisplay();
            } else {
                // ç§»é™¤å°¾éƒ¨
                snake.pop();
            }
            
            // ç»˜åˆ¶æ¸¸æˆ
            draw();
        }

        // æ¸¸æˆç»“æŸ
        function gameOver() {
            gameRunning = false;
            clearInterval(gameLoop);
            clearInterval(aiLoop);
            
            document.getElementById('gameOver').style.display = 'block';
        }

        // æ›´æ–°é€Ÿåº¦
        function updateSpeed() {
            if (score > 0 && score % 3 === 0) {
                const newSpeed = Math.max(MIN_SPEED, currentSpeed - SPEED_INCREMENT);
                
                if (newSpeed !== currentSpeed) {
                    currentSpeed = newSpeed;
                    
                    // é‡æ–°å¯åŠ¨æ¸¸æˆå¾ªç¯ä»¥åº”ç”¨æ–°é€Ÿåº¦
                    if (gameRunning && !gamePaused) {
                        clearInterval(gameLoop);
                        startGameLoop();
                        
                        // æ›´æ–°AIé€Ÿåº¦
                        if (aiMode) {
                            restartAIControl();
                        }
                    }
                }
            }
        }

        // æ›´æ–°æ˜¾ç¤º
        function updateDisplay() {
            const elements = getElements();
            elements.scoreElement.textContent = score;
            elements.speedElement.textContent = currentSpeed;
            elements.boundaryElement.textContent = boundaryEnabled ? 'å¼€å¯' : 'å…³é—­';
            elements.aiElement.textContent = aiMode ? 'å¼€å¯' : 'å…³é—­';
        }

        // å¼€å§‹æ¸¸æˆå¾ªç¯
        function startGameLoop() {
            gameLoop = setInterval(update, currentSpeed);
        }

        // é‡æ–°å¼€å§‹æ¸¸æˆ
        function restartGame() {
            document.getElementById('gameOver').style.display = 'none';
            clearInterval(gameLoop);
            clearInterval(aiLoop);
            initGame();
        }

        // æš‚åœ/ç»§ç»­æ¸¸æˆ
        function togglePause() {
            if (!gameRunning) return;
            
            gamePaused = !gamePaused;
            
            if (gamePaused) {
                clearInterval(gameLoop);
                clearInterval(aiLoop);
                document.getElementById('pauseMenu').style.display = 'block';
            } else {
                startGameLoop();
                if (aiMode) {
                    startAIControl();
                }
                document.getElementById('pauseMenu').style.display = 'none';
            }
        }

        // ä»æš‚åœèœå•é‡æ–°å¼€å§‹
        function restartFromPause() {
            document.getElementById('pauseMenu').style.display = 'none';
            restartGame();
        }

        // æ˜¾ç¤ºç©æ³•ä»‹ç»
        function showInstructions() {
            document.getElementById('instructionsMenu').style.display = 'block';
        }

        // éšè—ç©æ³•ä»‹ç»
        function hideInstructions() {
            document.getElementById('instructionsMenu').style.display = 'none';
        }

        // åˆ‡æ¢è¾¹ç•Œå¼€å…³
        function toggleBoundary() {
            boundaryEnabled = !boundaryEnabled;
            updateDisplay();
        }

        // åˆ‡æ¢AIæ¨¡å¼
        function toggleAIMode() {
            aiMode = !aiMode;
            updateDisplay();
            
            if (aiMode) {
                startAIControl();
            } else {
                stopAIControl();
            }
        }

        // å¯åŠ¨AIæ§åˆ¶
        function startAIControl() {
            if (!aiMode || !gameRunning || gamePaused) return;
            
            // è®¾ç½®AIæ§åˆ¶é—´éš”ä¸ºæ¸¸æˆé€Ÿåº¦çš„ä¸€åŠï¼Œä½†ä¸è¶…è¿‡100ms
            aiIntervalTime = Math.min(currentSpeed / 2, 100);
            aiLoop = setInterval(aiControl, aiIntervalTime);
            console.log('AIæ§åˆ¶å·²å¯åŠ¨ï¼Œé—´éš”ï¼š' + aiIntervalTime + 'ms');
        }

        // åœæ­¢AIæ§åˆ¶
        function stopAIControl() {
            if (aiLoop) {
                clearInterval(aiLoop);
                aiLoop = null;
                console.log('AIæ§åˆ¶å·²åœæ­¢');
            }
        }

        // é‡å¯AIæ§åˆ¶ï¼ˆç”¨äºé€Ÿåº¦å˜åŒ–æ—¶ï¼‰
        function restartAIControl() {
            stopAIControl();
            if (aiMode && gameRunning && !gamePaused) {
                startAIControl();
            }
        }

        // æ›¼å“ˆé¡¿è·ç¦»è®¡ç®—
        function manhattanDistance(pos1, pos2) {
            return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);
        }

        // æ£€æŸ¥ä½ç½®æ˜¯å¦å®‰å…¨
        function isSafePosition(x, y, snakeBody) {
            if (boundaryEnabled) {
                if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) {
                    return false;
                }
            } else {
                // è¾¹ç•Œç©¿è¶Šé€»è¾‘
                if (x < 0) x = GRID_SIZE - 1;
                if (x >= GRID_SIZE) x = 0;
                if (y < 0) y = GRID_SIZE - 1;
                if (y >= GRID_SIZE) y = 0;
            }
            
            return !snakeBody.some(segment => segment.x === x && segment.y === y);
        }

        // è·å–å®‰å…¨çš„é‚»å±…ä½ç½®
        function getSafeNeighbors(position, snakeBody) {
            const neighbors = [];
            const directions = [
                { x: 0, y: -1, dir: 'up' },
                { x: 0, y: 1, dir: 'down' },
                { x: -1, y: 0, dir: 'left' },
                { x: 1, y: 0, dir: 'right' }
            ];
            
            directions.forEach(dir => {
                let newX = position.x + dir.x;
                let newY = position.y + dir.y;
                
                // å¤„ç†è¾¹ç•Œç©¿è¶Š
                if (!boundaryEnabled) {
                    if (newX < 0) newX = GRID_SIZE - 1;
                    else if (newX >= GRID_SIZE) newX = 0;
                    if (newY < 0) newY = GRID_SIZE - 1;
                    else if (newY >= GRID_SIZE) newY = 0;
                }
                
                if (isSafePosition(newX, newY, snakeBody)) {
                    neighbors.push({ x: newX, y: newY, dir: dir.dir });
                }
            });
            
            return neighbors;
        }

        // AIæ§åˆ¶å‡½æ•° - ä¿®å¤ç‰ˆæœ¬
        function aiControl() {
            if (!aiMode || !gameRunning || gamePaused) return;
            
            console.log('AIæ§åˆ¶æ‰§è¡Œä¸­...');
            
            // ä½¿ç”¨æ™ºèƒ½å¯»è·¯ç®—æ³•æ‰¾åˆ°æœ€ä½³æ–¹å‘
            const bestDirection = findPathToFood();
            
            if (bestDirection) {
                // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ‰§è¡Œè¿™ä¸ªæ–¹å‘ï¼ˆé¿å…180åº¦è½¬å¼¯ï¼‰
                const opposites = {
                    'up': 'down',
                    'down': 'up',
                    'left': 'right',
                    'right': 'left'
                };
                
                if (direction !== opposites[bestDirection]) {
                    nextDirection = bestDirection;
                    console.log('AIé€‰æ‹©æ–¹å‘ï¼š' + bestDirection);
                } else {
                    console.log('AIæ–¹å‘å†²çªï¼Œå½“å‰ï¼š' + direction + 'ï¼Œå»ºè®®ï¼š' + bestDirection);
                    // å¦‚æœæœ€ä½³æ–¹å‘æ˜¯ç›¸åæ–¹å‘ï¼Œé€‰æ‹©å…¶ä»–å®‰å…¨æ–¹å‘
                    const safeDirections = getSafeNeighbors(snake[0], snake);
                    const availableDirections = safeDirections.filter(neighbor => 
                        neighbor.dir !== opposites[direction]
                    );
                    
                    if (availableDirections.length > 0) {
                        nextDirection = availableDirections[0].dir;
                        console.log('AIé€‰æ‹©æ›¿ä»£æ–¹å‘ï¼š' + nextDirection);
                    }
                }
            } else {
                console.log('AIæœªæ‰¾åˆ°åˆé€‚è·¯å¾„');
                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°è·¯å¾„ï¼Œé€‰æ‹©éšæœºå®‰å…¨æ–¹å‘
                const safeDirections = getSafeNeighbors(snake[0], snake);
                const opposites = { 'up': 'down', 'down': 'up', 'left': 'right', 'right': 'left' };
                const availableDirections = safeDirections.filter(neighbor => 
                    neighbor.dir !== opposites[direction]
                );
                
                if (availableDirections.length > 0) {
                    const randomDirection = availableDirections[Math.floor(Math.random() * availableDirections.length)];
                    nextDirection = randomDirection.dir;
                    console.log('AIéšæœºé€‰æ‹©æ–¹å‘ï¼š' + nextDirection);
                }
            }
        }

        // æ™ºèƒ½å¯»è·¯ç®—æ³• - ä¼˜åŒ–ååº”é€Ÿåº¦
        function findPathToFood() {
            if (!gameRunning || gamePaused || snake.length === 0) return null;

            const head = snake[0];
            const tail = snake[snake.length - 1];

            // Helper function for BFS
            function bfs(start, target, obstacles, currentSnakeDirection = null) {
                const queue = [{ x: start.x, y: start.y, path: [] }];
                const visited = new Set();
                visited.add(`${start.x},${start.y}`);

                const directions = [{ dx: 0, dy: -1, dir: 'up' }, { dx: 0, dy: 1, dir: 'down' }, { dx: -1, dy: 0, dir: 'left' }, { dx: 1, dy: 0, dir: 'right' }];
                const opposites = { 'up': 'down', 'down': 'up', 'left': 'right', 'right': 'left' };

                while (queue.length > 0) {
                    const { x, y, path } = queue.shift();

                    if (x === target.x && y === target.y) {
                        return path;
                    }

                    for (const { dx, dy, dir } of directions) {
                        // Avoid 180-degree turns for the first step
                        if (path.length === 0 && currentSnakeDirection && dir === opposites[currentSnakeDirection]) {
                            continue;
                        }

                        const nx = x + dx;
                        const ny = y + dy;
                        const newPos = { x: nx, y: ny };

                        // Check boundaries
                        if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) continue;

                        // Check obstacles (snake body)
                        if (obstacles.some(segment => segment.x === nx && segment.y === ny)) continue;

                        if (!visited.has(`${nx},${ny}`)) {
                            visited.add(`${nx},${ny}`);
                            queue.push({ x: nx, y: ny, path: [...path, dir] });
                        }
                    }
                }
                return null; // No path found
            }

            // 1. Try to find a path to food
            const pathToFood = bfs(head, food, snake.slice(0, -1), direction); // Pass current direction

            if (pathToFood && pathToFood.length > 0) {
                // Simulate taking the first step towards food
                const firstMoveDir = pathToFood[0];
                let nextHead = { x: head.x, y: head.y };
                if (firstMoveDir === 'up') nextHead.y--;
                else if (firstMoveDir === 'down') nextHead.y++;
                else if (firstMoveDir === 'left') nextHead.x--;
                else if (firstMoveDir === 'right') nextHead.x++;

                // Check if after this move, the snake can still reach its tail
                // The new snake body for this check would be [nextHead, ...snake.slice(0, -1)]
                const simulatedSnakeBody = [nextHead, ...snake.slice(0, -1)];
                // When checking path to tail, the current direction is the direction of nextHead
                const pathFromNextHeadToTail = bfs(nextHead, tail, simulatedSnakeBody.slice(0, -1), firstMoveDir);

                if (pathFromNextHeadToTail) {
                    // If a path to tail exists, it's a safe move towards food
                    console.log('AI: Found safe path to food via BFS.');
                    return firstMoveDir;
                } else {
                    console.log('AI: Path to food found, but not safe (cannot reach tail).');
                }
            } else {
                console.log('AI: No path to food found via BFS.');
            }

            // 2. If no safe path to food, try to find a path to the tail
            const pathToTail = bfs(head, tail, snake.slice(0, -1), direction); // Pass current direction
            if (pathToTail && pathToTail.length > 0) {
                console.log('AI: Found path to tail via BFS.');
                return pathToTail[0];
            } else {
                console.log('AI: No path to tail found via BFS.');
            }

            // 3. If no path to food or tail, resort to finding any safe direction
            const safeDirections = getSafeNeighbors(head, snake);
            const opposites = { 'up': 'down', 'down': 'up', 'left': 'right', 'right': 'left' };
            const availableDirections = safeDirections.filter(neighbor =>
                neighbor.dir !== opposites[direction]
            );

            if (availableDirections.length > 0) {
                console.log('AI: Resorting to available safe directions.');
                // Prioritize directions that don't immediately lead to fewer safe spots
                availableDirections.sort((a, b) => {
                    const testSnakeA = [a, ...snake.slice(0, -1)];
                    const futureNeighborsA = getSafeNeighbors(a, testSnakeA);
                    const testSnakeB = [b, ...snake.slice(0, -1)];
                    const futureNeighborsB = getSafeNeighbors(b, testSnakeB);
                    return futureNeighborsB.length - futureNeighborsA.length;
                });
                return availableDirections[0].dir;
            }

            console.log('AI: No safe direction found, game over imminent.');
            return null; // Game over soon
        }

        // é”®ç›˜äº‹ä»¶å¤„ç†
        document.addEventListener('keydown', function(event) {
            if (!gameRunning) return;
            
            // é¦–å…ˆå¤„ç†åŠŸèƒ½é”®ï¼ˆä¸ä¾èµ–äºæ¸¸æˆæš‚åœçŠ¶æ€ï¼‰
            switch (event.key.toLowerCase()) {
                case 'p':
                    togglePause();
                    return;
                case 'c':
                    toggleBoundary();
                    return;
                case 'q':  // ä½¿ç”¨Qé”®ä»£æ›¿Aé”®å¼€å¯AIï¼Œé¿å…ä¸å·¦ç§»å†²çª
                    toggleAIMode();
                    return;
            }
            
            // å¦‚æœæ¸¸æˆæš‚åœï¼Œä¸å¤„ç†ç§»åŠ¨é”®
            if (gamePaused) return;
            
            // å¤„ç†ç§»åŠ¨é”®
            switch (event.key.toLowerCase()) {
                case 'arrowup':
                case 'w':
                    if (direction !== 'down') nextDirection = 'up';
                    break;
                case 'arrowdown':
                case 's':
                    if (direction !== 'up') nextDirection = 'down';
                    break;
                case 'arrowleft':
                case 'a':
                    if (direction !== 'right') nextDirection = 'left';
                    break;
                case 'arrowright':
                case 'd':
                    if (direction !== 'left') nextDirection = 'right';
                    break;
            }
        });

        // ç§»åŠ¨ç«¯æ§åˆ¶
        function handleMobileControl(action) {
            if (!gameRunning) return;
            
            switch (action) {
                case 'up':
                    if (direction !== 'down') nextDirection = 'up';
                    break;
                case 'down':
                    if (direction !== 'up') nextDirection = 'down';
                    break;
                case 'left':
                    if (direction !== 'right') nextDirection = 'left';
                    break;
                case 'right':
                    if (direction !== 'left') nextDirection = 'right';
                    break;
                case 'pause':
                    togglePause();
                    break;
                case 'boundary':
                    toggleBoundary();
                    break;
                case 'ai':
                    toggleAIMode();
                    break;
                case 'restart':
                    restartGame();
                    break;
            }
            
            mobileControlActive = true;
            mobileControlDirection = action;
        }

        function stopMobileControl() {
            mobileControlActive = false;
            mobileControlDirection = null;
        }

        // çª—å£å¤§å°æ”¹å˜æ—¶è°ƒæ•´ç”»å¸ƒ
        window.addEventListener('resize', function() {
            adjustCanvasSize();
            draw();
        });

        // é˜²æ­¢é¡µé¢æ»šåŠ¨å’Œç¼©æ”¾
        document.addEventListener('touchmove', function(event) {
            event.preventDefault();
        }, { passive: false });

        document.addEventListener('gesturestart', function(event) {
            event.preventDefault();
        });

        document.addEventListener('gesturechange', function(event) {
            event.preventDefault();
        });

        document.addEventListener('gestureend', function(event) {
            event.preventDefault();
        });

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–æ¸¸æˆ
        window.addEventListener('load', function() {
            initGame();
        });

        // é¡µé¢å¯è§æ€§æ”¹å˜æ—¶çš„å¤„ç†
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                // é¡µé¢éšè—æ—¶æš‚åœæ¸¸æˆ
                if (gameRunning && !gamePaused) {
                    togglePause();
                }
            }
        });

        // é˜²æ­¢åŒå‡»ç¼©æ”¾
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function(event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
    </script>
</body>
</html>